/**
 * NeoCard Component - Widget Template
 * 
 * Acts as the widget template that handles:
 * - Pagination logic for condensed view
 * - Page indicator display
 * - Expand button
 * - Title rendering
 * 
 * Widgets define their pages and expanded view, and NeoCard handles all the
 * pagination, scrolling, and UI infrastructure.
 * 
 * Used by: All widget components (StockPriceCard, TotalBalanceCard, etc.)
 */
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { View, Text, StyleSheet, ScrollView, Dimensions, NativeScrollEvent, NativeSyntheticEvent, Modal, Animated, Easing, LayoutChangeEvent, ScaledSize } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import Svg, { Defs, LinearGradient, Stop, Rect, Pattern, Circle } from 'react-native-svg';
import { BlurView } from 'expo-blur';
import { colors } from '../../theme/colors';
import { typography } from '../../theme/typography';
import { NeoDotsButton } from './NeoDotsButton';
import { WidgetPageIndicator } from '../widgets/WidgetPageIndicator';
import { BackgroundTexture } from './BackgroundTexture';

export const CARD_RADIUS = 6;

const OPEN_DURATION = 420;
const CLOSE_DURATION = 260;
const OPEN_EASING = Easing.bezier(0.22, 0.61, 0.36, 1);
const CLOSE_EASING = Easing.bezier(0.4, 0, 0.2, 1);

type CardLayout = {
  x: number;
  y: number;
  width: number;
  height: number;
};

export type NeoCardProps = {
  title: string;                    // Title generated by widget from payload
  onExpand?: () => void;           // Callback when expand button is pressed
  expanded?: boolean;              // Whether widget is in expanded view
  condensedPages?: React.ReactElement[]; // Pages for condensed view (from widget)
  expandedView?: React.ReactElement;      // Content for expanded view (from widget)
  expandedTopOffset?: number;            // Optional top offset for expanded overlay (e.g., header height)
  expandedBottomOffset?: number;        // Optional bottom offset for expanded overlay (e.g., tab bar height)
};

export const NeoCard: React.FC<NeoCardProps> = ({ 
  title, 
  onExpand, 
  expanded = false,
  condensedPages = [],
  expandedView,
  expandedTopOffset = 0,
  expandedBottomOffset = 0,
}) => {
  const [currentPage, setCurrentPage] = useState(0);
  const scrollViewRef = useRef<ScrollView>(null);
  const expandedScrollViewRef = useRef<ScrollView>(null);
  const [cardWidth, setCardWidth] = useState(() => Dimensions.get('window').width - 36);
  const [scrollViewHeight, setScrollViewHeight] = useState(0);
  const totalPages = condensedPages.length;
  const [overlayVisible, setOverlayVisible] = useState(false);
  const [cardLayout, setCardLayout] = useState<CardLayout | null>(null);
  const [windowSize, setWindowSize] = useState(() => Dimensions.get('window'));
  const animationProgress = useRef(new Animated.Value(0)).current;
  const cardWrapperRef = useRef<View | null>(null);
  const [transitionState, setTransitionState] = useState<'idle' | 'opening' | 'closing'>('idle');
  
  // Generate unique IDs for SVG gradients to avoid conflicts
  const cardId = useRef(Math.random().toString(36).substring(2, 11)).current;

  // Helper to create gradient stops (reused across multiple gradients)
  const gradientStops = [
    <Stop key="0" offset="0%" stopColor={colors.pastelBlue} stopOpacity="0.55" />,
    <Stop key="1" offset="50%" stopColor={colors.pastelMint} stopOpacity="0.45" />,
    <Stop key="2" offset="100%" stopColor={colors.pastelBlush} stopOpacity="0.55" />,
  ];

  // Handle scroll for pagination
  const maybeUpdateWidth = (nextWidth: number) => {
    if (!nextWidth) return;
    setCardWidth(prev => (Math.abs(prev - nextWidth) < 0.5 ? prev : nextWidth));
  };

  const measureCard = useCallback((onMeasured?: () => void) => {
    if (!cardWrapperRef.current || typeof cardWrapperRef.current.measureInWindow !== 'function') {
      onMeasured?.();
      return;
    }

    requestAnimationFrame(() => {
      cardWrapperRef.current?.measureInWindow?.((x, y, width, height) => {
        if (typeof x === 'number' && typeof y === 'number' && typeof width === 'number' && typeof height === 'number') {
          setCardLayout({ x, y, width, height });
        }
        onMeasured?.();
      });
    });
  }, []);

  const handleCardLayout = useCallback((_event?: LayoutChangeEvent) => {
    measureCard();
  }, [measureCard]);

  const handleScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {
    const { contentOffset, layoutMeasurement } = event.nativeEvent;
    if (layoutMeasurement?.width) {
      maybeUpdateWidth(layoutMeasurement.width);
    }
    const width = layoutMeasurement?.width || cardWidth || 1;
    const page = Math.round(contentOffset.x / width);
    setCurrentPage(page);
  };

  useEffect(() => {
    const handler = ({ window }: { window: ScaledSize }) => {
      setWindowSize(window);
      measureCard();
    };

    const subscription = Dimensions.addEventListener('change', handler);

    return () => {
      if (subscription && typeof subscription.remove === 'function') {
        subscription.remove();
      }
    };
  }, [measureCard]);

  const openAnimation = useCallback(() => {
    setTransitionState('opening');
    setOverlayVisible(true);
    animationProgress.stopAnimation();
    animationProgress.setValue(0);
    Animated.timing(animationProgress, {
      toValue: 1,
      duration: OPEN_DURATION,
      easing: OPEN_EASING,
      useNativeDriver: false,
    }).start(() => {
      setTransitionState('idle');
    });
  }, [animationProgress]);

  const closeAnimation = useCallback(() => {
    setTransitionState('closing');
    animationProgress.stopAnimation();
    Animated.timing(animationProgress, {
      toValue: 0,
      duration: CLOSE_DURATION,
      easing: CLOSE_EASING,
      useNativeDriver: false,
    }).start(({ finished }) => {
      if (finished) {
        animationProgress.setValue(0);
        setOverlayVisible(false);
        setTransitionState('idle');
      }
    });
  }, [animationProgress]);

  useEffect(() => {
    if (expanded && !overlayVisible) {
      if (cardLayout) {
        openAnimation();
      } else {
        measureCard(openAnimation);
      }
    } else if (!expanded && overlayVisible) {
      closeAnimation();
    }
  }, [expanded, overlayVisible, cardLayout, openAnimation, closeAnimation, measureCard]);

  const fallbackHeight = cardLayout?.height ?? Math.max(scrollViewHeight, 220);
  const baseLayout: CardLayout = cardLayout ?? {
    x: 12,
    y: expandedTopOffset + 12,
    width: cardWidth,
    height: fallbackHeight,
  };

  const targetWidth = windowSize.width;
  const targetHeight = Math.max(windowSize.height - expandedTopOffset - expandedBottomOffset, 1);

  const animatedCardPosition = {
    top: animationProgress.interpolate({
      inputRange: [0, 1],
      outputRange: [baseLayout.y, expandedTopOffset],
    }),
    left: animationProgress.interpolate({
      inputRange: [0, 1],
      outputRange: [baseLayout.x, 0],
    }),
    width: animationProgress.interpolate({
      inputRange: [0, 1],
      outputRange: [baseLayout.width, targetWidth],
    }),
    height: animationProgress.interpolate({
      inputRange: [0, 1],
      outputRange: [baseLayout.height, targetHeight],
    }),
  } as const;

  const animatedBorderRadius = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [CARD_RADIUS, 0],
  });

  const animatedPaddingHorizontal = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [24, 0],
  });

  const animatedPaddingTop = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [14, 0],
  });

  const animatedPaddingBottom = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [18, 0],
  });

  const animatedBorderWidth = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0],
  });

  const animatedShadowOpacity = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [0.26, 0],
  });

  const overlayOpacity = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 1],
  });

  const contentOpacity = animationProgress.interpolate({
    inputRange: [0, 0.55, 1],
    outputRange: [0, 0.1, 1],
  });

  const animatedBackgroundColor = animationProgress.interpolate({
    inputRange: [0, 1],
    outputRange: [colors.cardBg, colors.screenBg],
  });

  const shouldShowCondensed = !expanded || transitionState === 'opening';
  const shouldRenderExpandedContent = overlayVisible && transitionState !== 'opening';
  const condensedOpacity = transitionState === 'opening'
    ? animationProgress.interpolate({
        inputRange: [0, 0.35, 0.7, 1],
        outputRange: [1, 0.85, 0.3, 0],
        extrapolate: 'clamp',
      })
    : 1;

  const expandedHeader = (
    <View style={styles.titleContainerSticky}>
      <View style={styles.titleRow}>
        <Text style={styles.title}>{title}</Text>
        {onExpand && (
          <NeoDotsButton onPress={onExpand} expanded={overlayVisible} style={styles.expand} testID="expand-btn" />
        )}
      </View>
      <View style={styles.stickyHeaderStripe} pointerEvents="none">
        <View style={styles.greyLine} />
      </View>
    </View>
  );

  return (
    <>
      <View
        ref={cardWrapperRef}
        style={styles.cardWrapper}
        onLayout={handleCardLayout}
      >
        <View
          style={styles.card}
          pointerEvents={overlayVisible ? 'none' : 'auto'}
        >
          {shouldShowCondensed && (
            <View style={styles.patternOverlay} pointerEvents="none">
              <Svg width="100%" height="100%" style={StyleSheet.absoluteFill}>
                <Defs>
                  <Pattern id={`dotPattern-${cardId}`} x="0" y="0" width="8" height="8" patternUnits="userSpaceOnUse">
                    <Circle cx="4" cy="4" r="0.5" fill={colors.ink} opacity="0.03" />
                  </Pattern>
                </Defs>
                <Rect width="100%" height="100%" fill={`url(#dotPattern-${cardId})`} />
              </Svg>
            </View>
          )}

          {shouldShowCondensed && (
            <View style={styles.headerStripe} pointerEvents="none">
              <View style={styles.greyLine} />
            </View>
          )}

          {shouldShowCondensed && (
            <View style={styles.innerGlow} pointerEvents="none">
              <Svg width="100%" height="100%" style={StyleSheet.absoluteFill}>
                <Defs>
                  <LinearGradient id={`innerGlowTop-${cardId}`} x1="0%" y1="0%" x2="0%" y2="100%">
                    <Stop offset="0%" stopColor={colors.pastelLilac} stopOpacity="0.08" />
                    <Stop offset="100%" stopColor="transparent" stopOpacity="0" />
                  </LinearGradient>
                  <LinearGradient id={`innerGlowBottom-${cardId}`} x1="0%" y1="100%" x2="0%" y2="0%">
                    <Stop offset="0%" stopColor={colors.pastelBlush} stopOpacity="0.06" />
                    <Stop offset="100%" stopColor="transparent" stopOpacity="0" />
                  </LinearGradient>
                  <LinearGradient id={`innerGlowLeft-${cardId}`} x1="0%" y1="0%" x2="100%" y2="0%">
                    <Stop offset="0%" stopColor={colors.pastelBlue} stopOpacity="0.05" />
                    <Stop offset="100%" stopColor="transparent" stopOpacity="0" />
                  </LinearGradient>
                  <LinearGradient id={`innerGlowRight-${cardId}`} x1="100%" y1="0%" x2="0%" y2="0%">
                    <Stop offset="0%" stopColor={colors.pastelMint} stopOpacity="0.05" />
                    <Stop offset="100%" stopColor="transparent" stopOpacity="0" />
                  </LinearGradient>
                </Defs>
                <Rect width="100%" height="30%" fill={`url(#innerGlowTop-${cardId})`} />
                <Rect y="70%" width="100%" height="30%" fill={`url(#innerGlowBottom-${cardId})`} />
                <Rect width="30%" height="100%" fill={`url(#innerGlowLeft-${cardId})`} />
                <Rect x="70%" width="30%" height="100%" fill={`url(#innerGlowRight-${cardId})`} />
              </Svg>
            </View>
          )}

          <Animated.View style={[styles.contentLayer, { opacity: condensedOpacity }]}
          >
            {shouldShowCondensed && (
              <View style={styles.titleContainer}>
                <Text style={styles.title}>{title}</Text>
                {onExpand && (
                  <NeoDotsButton onPress={onExpand} expanded={expanded} style={styles.expand} testID="expand-btn" />
                )}
              </View>
            )}

            {shouldShowCondensed && totalPages > 0 ? (
              <ScrollView
                ref={scrollViewRef}
                horizontal
                pagingEnabled
                showsHorizontalScrollIndicator={false}
                onScroll={handleScroll}
                scrollEventThrottle={16}
                style={styles.scrollView}
                onLayout={(event) => {
                  maybeUpdateWidth(event.nativeEvent.layout.width);
                }}
              >
                {condensedPages.map((page, index) => (
                  <View key={index} style={[styles.page, { width: cardWidth }]}
                  >
                    {page}
                  </View>
                ))}
              </ScrollView>
            ) : null}

            {shouldShowCondensed && totalPages > 1 && (
              <WidgetPageIndicator currentPage={currentPage} totalPages={totalPages} />
            )}
          </Animated.View>
        </View>
      </View>

      {overlayVisible && (
        <Modal
          transparent
          visible={overlayVisible}
          animationType="none"
          statusBarTranslucent
          onRequestClose={onExpand}
        >
          <View style={StyleSheet.absoluteFill} pointerEvents="box-none">
            <Animated.View
              style={[
                styles.modalOverlay,
                {
                  opacity: overlayOpacity,
                  top: expandedTopOffset,
                  bottom: expandedBottomOffset,
                },
              ]}
              pointerEvents="none"
            >
              <BlurView intensity={20} style={StyleSheet.absoluteFill} />
            </Animated.View>

            <Animated.View
              style={[
                styles.expandedCardContainer,
                animatedCardPosition,
                {
                  borderRadius: animatedBorderRadius,
                  paddingHorizontal: animatedPaddingHorizontal,
                  paddingTop: animatedPaddingTop,
                  paddingBottom: animatedPaddingBottom,
                  borderWidth: animatedBorderWidth,
                  shadowOpacity: animatedShadowOpacity,
                  backgroundColor: animatedBackgroundColor,
                },
              ]}
            >
              <BackgroundTexture />
              {!shouldRenderExpandedContent && (
                <View style={styles.expandedPlaceholder} pointerEvents="none">
                  {expandedHeader}
                </View>
              )}
              {shouldRenderExpandedContent && (
                <Animated.View
                  style={[styles.expandedCardContentWrapper, { opacity: contentOpacity }]}
                >
                  <SafeAreaView style={styles.expandedSafeArea} edges={['bottom']}>
                    <ScrollView
                      ref={expandedScrollViewRef}
                      style={styles.expandedScrollView}
                      contentContainerStyle={styles.expandedScrollContent}
                      showsVerticalScrollIndicator={true}
                      stickyHeaderIndices={[0]}
                      onLayout={(event) => {
                        const { height } = event.nativeEvent.layout;
                        setScrollViewHeight(height);
                      }}
                    >
                      {expandedHeader}
                      <View style={[styles.expandedContent, scrollViewHeight > 0 && { minHeight: Math.max(scrollViewHeight - 80, 400) }]}>
                        {expandedView}
                      </View>
                    </ScrollView>
                  </SafeAreaView>
                </Animated.View>
              )}
            </Animated.View>

            {expandedBottomOffset > 0 && (
              <View pointerEvents="none" style={[styles.tabBarShim, { height: expandedBottomOffset }]} />
            )}
          </View>
        </Modal>
      )}
    </>
  );
};

const styles = StyleSheet.create({
  cardWrapper: {
    marginHorizontal: 12,
    marginVertical: 8,
    shadowColor: colors.ink,
    shadowOpacity: 0.26,
    shadowRadius: 3,
    shadowOffset: { width: 2, height: 6 },
    elevation: 12,
    borderRadius: CARD_RADIUS + 2,
    backgroundColor: 'transparent',
  },
  card: {
    backgroundColor: colors.cardBg,
    borderWidth: 1,
    borderColor: '#E0E0E0',
    borderRadius: CARD_RADIUS,
    paddingTop: 14,
    paddingBottom: 18,
    paddingHorizontal: 24,
    overflow: 'hidden',
  },
  patternOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 0,
  },
  headerStripe: {
    position: 'absolute',
    top: 46, // Position below title area - equal spacing from title
    left: 0,
    right: 0,
    height: 1,
    zIndex: 1,
  },
  innerGlow: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 0,
    pointerEvents: 'none',
  },
  contentLayer: {
    position: 'relative',
    zIndex: 2,
    flex: 1,
  },
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  titleContainerSticky: {
    backgroundColor: colors.cardBg, // Solid background for sticky header
    zIndex: 10,
  },
  titleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 12,
    paddingTop: 14,
    paddingHorizontal: 20, // Match screen edge padding
  },
  stickyHeaderStripe: {
    height: 1,
    width: '100%',
    position: 'relative',
  },
  greyLine: {
    width: '100%',
    height: 1,
    backgroundColor: '#E0E0E0',
  },
  title: { 
    ...typography.heading,
    fontSize: 17,
    color: colors.ink,
    letterSpacing: -0.4,
    flex: 1,
  },
  expand: { 
    marginLeft: 12,
  },
  scrollView: {
    marginHorizontal: -24, // Offset card padding for full-width scrolling
  },
  page: {
    alignItems: 'flex-start',
    justifyContent: 'flex-start',
    paddingHorizontal: 24,
  },
  expandedScrollView: {
    flex: 1,
  },
  expandedScrollContent: {
    flexGrow: 1,
    minHeight: '100%',
  },
  expandedContent: {
    paddingHorizontal: 20, // Consistent padding from screen edges
    backgroundColor: colors.cardBg,
    flexGrow: 1,
    minHeight: 400,
  },
  modalOverlay: {
    position: 'absolute',
    left: 0,
    right: 0,
    backgroundColor: 'rgba(0,0,0,0.28)',
  },
  expandedCardContainer: {
    position: 'absolute',
    overflow: 'hidden',
    borderColor: '#E0E0E0',
    shadowColor: colors.ink,
    shadowOffset: { width: 2, height: 6 },
    shadowRadius: 3,
    elevation: 12,
  },
  expandedPlaceholder: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: colors.cardBg,
    justifyContent: 'flex-start',
  },
  expandedCardContentWrapper: {
    flex: 1,
  },
  expandedSafeArea: {
    flex: 1,
  },
  tabBarShim: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'transparent',
    borderTopWidth: 1,
    borderTopColor: '#E0E0E0',
    shadowColor: colors.ink,
    shadowOffset: { width: 0, height: -2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 8,
  },
});

